#!/usr/bin/env ruby
require 'securerandom'
require 'timeout'

APP_PATH = File.expand_path('../../config/application',  __FILE__)
require File.expand_path('../../config/boot',  __FILE__)
require APP_PATH
Rails.application.require_environment!

job = GradingJob.find(ARGV[0])
job.started_at = Time.now
job.save!

sub = job.submission

if job.nil?
  puts "Must provide valid job id."
  exit(0)
end

unless sub.assignment.has_grading?
  puts "No grading file. Submission must be graded manually."
  exit(0)
end

def run(cmd)
  system(cmd) or do
    puts "Error running command: #{cmd}"
    exit(1)
  end
end

class Container
  def initialize(name)
    @name = name
  end

  def start!
    run(
      %Q{lxc launch bn-base #{@name} \
           -c "limits.cpu.allowance=10ms/50ms" \
           -c "limits.memory=512MB" \
           -c "limits.processes=256"}
    )
  end

  def mkdir(path, mode = 0755)
    run(%Q{lxc exec #{@name} -- mkdir -m 0#{mode.to_s(8)} -p #{path}})
  end

  def push(src, dst)
    run(%Q{lxc push "#{src}" "#{@name}/#{dst}"})
  end

  def pull(src, dst)
    raise Exception.new("TODO")
  end

  def chmod(path, mode)
    run(%Q{lxc exec #{@name} -- chmod 0#{mode.to_s(8)} "#{path}"})
  end

  def stop!
    run("lxc stop #{@name}")
  end
end

# Boot up the container.
con = Container.new("bn-#{job.id}")
con.start!

# Copy the files into the container.
con.mkdir("/tmp/bn")

con.mkdir("/tmp/bn/sub")
con.push(sub.file_full_path, "/tmp/bn/sub/#{sub.upload.file_name}")

con.mkdir("/tmp/bn/gra")
gra_up = sub.assignment.grading_upload
con.push(sub.grading_full_path, "/tmp/bn/gra/#{gra_up.file_name}")

con.mkdir("/tmp/bn/lib")
bnlib = Rails.root.join("grading", "scripts", "bnlib.rb")
con.push(bnlib, "/tmp/bn/lib/bnlib.rb")

# Make a test output key, copy that over.
output_key = SecureRandom.urlsafe_base64

key = Tempfile.new("output_key")
key.puts(output_key)
key.close
con.push(key.path, "/root/bn_output_key"})
key.unlink

# Exec the grading script.
pipe = File.popen(%Q{lxc exec #{con_name} -- bash -c '(cd && "./#{job.driver_script_path}")'})

output_lines = []

begin
  Timeout::timeout(150) do
    begin
      while not pipe.eof?
        line = pipe.readline()
        if line
          puts line
          output_lines << line
          sub.grading_output = output_lines.join
          sub.save!
        end
      end
    rescue Exception => ee
      output_lines << ee.to_s
      sub.grading_output = output_lines.join
      sub.save!
      
      output_lines = []
    end
  end

  #sub.parse_output!
rescue Exception => ee
  output_lines << ee.to_s
  output_lines << "\n\n Timeout! \n\n"
  sub.save!
end

job.destroy
